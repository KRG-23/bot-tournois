// Prisma schema placeholder — to be expanded with Tournament domain entities
generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Tournament {
  id        String   @id @default(uuid())
  name      String
  timezone  String
  status    String   @default("draft")
  published Boolean  @default(false)
  rulesUrl  String?
  location  String?
  startDate DateTime?
  endDate   DateTime?
  capacity  Int?
  roundsJson   Json?
  scheduleJson Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  players   Player[]
  rounds    Round[]
}

model Player {
  id           String   @id @default(uuid())
  tournamentId String
  name         String
  faction      String?
  pseudo       String?
  discordId    String?
  status       PlayerStatus   @default(PENDING)
  listStatus   ListStatus     @default(LIST_NOT_SUBMITTED)
  paymentStatus PaymentStatus @default(PAYMENT_PENDING)
  active       Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  pairingsA    Pairing[]  @relation("PlayerA")
  pairingsB    Pairing[]  @relation("PlayerB")

  @@index([discordId])
}

enum PlayerStatus {
  PENDING   // Inscription en attente (liste et/ou paiement à valider)
  VALIDATED // Inscription validée
}

enum ListStatus {
  LIST_WAITING       // Liste soumise, en attente de validation
  LIST_ACCEPTED      // Liste acceptée
  LIST_REFUSED       // Liste refusée
  LIST_NOT_SUBMITTED // Liste non fournie
}

enum PaymentStatus {
  PAYMENT_PENDING  // Paiement non reçu
  PAYMENT_ACCEPTED // Paiement reçu/validé
}

enum PairResult {
  WIN
  LOSS
  DRAW
}

model Round {
  id           String   @id @default(uuid())
  tournamentId String
  number       Int
  createdAt    DateTime @default(now())

  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  pairings     Pairing[]

  @@unique([tournamentId, number])
}

model Pairing {
  id         String   @id @default(uuid())
  roundId    String
  table      Int
  playerAId  String
  playerBId  String?
  scoreA     Int?
  scoreB     Int?
  resultA    PairResult?
  resultB    PairResult?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  round      Round   @relation(fields: [roundId], references: [id], onDelete: Cascade)
  playerA    Player  @relation("PlayerA", fields: [playerAId], references: [id], onDelete: Cascade)
  playerB    Player? @relation("PlayerB", fields: [playerBId], references: [id])

  @@unique([roundId, table])
}
